<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API测试</title>
    <url>/posts/873cc8b2/</url>
    <content><![CDATA[<h1 id="9种API测试"><a href="#9种API测试" class="headerlink" title="9种API测试"></a>9种API测试</h1><span id="more"></span>

<p><img src="/../images/c53f283e-6834-45b6-beb9-57b10b2a22fd_1280x1664.webp" alt="c53f283e-6834-45b6-beb9-57b10b2a22fd_1280x1664.webp"></p>
]]></content>
  </entry>
  <entry>
    <title>2024.01日记</title>
    <url>/posts/2916158c/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="420711e44b91bd806682edb620d728648c94b8d840538572ce96e78630cd74ee">e6394f24cbc4b9c257a947e9735531adc80f92c0a435f145d2b7d92005eb09691bf88f1c30a998f6c0d60205712c165c9c66f3e2cedc8c95185c0e75691edeae83d3da603b7d3f91fdcc3ba1c4aa6301079eec14d070aec482cec3b05c61500034d2c5d830d991262d874bcd492279f858a074440dd12cc589bbba990d48fe0ddcd3b9531c366e7186395d88fde3942faabc113fb683c013fdcc4bd49ecf253f4f2ee2163db80af0c764b965750cf3232ac638371bed5d508b082395822c7fda4dc54ae0eb29e7b1a670feeff2ffa4d48b2999be9482ef0691a10a56783ebd6736709f3cd0345a56c4a25259911cf54b130cb8b0e9544fc79c791db9e83ee985110b895a78c964a5840dd01fce7ec5b217ada5677969028a1207bac6ba383ea47e89457bb9e9f4a4ce8e15d326dc06124a706cd3696bf1b585a7afbe84f18e7885f7f77ee7749419914cd83a465fac28ca4bb269143f8ea8527ed6cf3a72903b99ae18b25da2f8f40a2f4413a987cd3711dc08cec5512f43452142d3cce1426c6f2402c627a9a5867996fbb53cffa022f940b2af45e682f60e73cfabae07067c1d90f842c77bcc42e9882c6515daa5dbbca94d291532476a46c5f913be070527c991a17671a6a04a4c71e8174879325bd08b6fb8500c659bf0e777f8fb64a00a0b9315361205126413b10597a5868e306fae487c735e524edb8ed3b88ebe309dd740a9cf4c062c2d0aa01b6ea347505a7b2ff456e9af067d8a55692586df3debabd02706c4dfdb20724809340de7add6036306c3de3fa38d46f7b65cc7a0a90cf9151fcc6fc4946ccdb50338b0a8e55488d1ca7b57defa73e1eace29add1650d670d0f8b623addc09e215c9552a973f076a6b070d9dc90e3f481398fb345663b83bb241e777d34791599e5c5313a648710057ef5c75ecd11ff0ebf995511592de4233a6ed8fb2cbd0db47b226e1fcd3ec4c4991259096c0dbc6047bea0cff5b3d6513c06a1a20172d8caf7ae9249d233c1e40a1834743d77d83474e677c168476fd89959a23df89d8c0a8e60eef4d996f1bf518a0260ee89d5004f349e74084a3a89d6c4a2f148f11a9d3bedc0c765b4ec0eb518eb92fc407ededf15f47fdec2f2c6a1153bf24fbf4c4b66c6db46211e2c46f0d3d9008873cfbd474279a991b70d47170f0f65caef41ca7800703b90b7cdcf9f13c01098f2b65dab0c32b43ac13f636ce2ceaba2cc339885c185f124a0318f53152145921f5079797d67d9cbce5b4fbb44f216fa0aff71a0f67520428f888012880f9d2766703ebd9bf41c0c27b9d6f2ecd35dfe649dafe57dea663099a530bd9b6c789f903e01ab564924fc26978795b7f4bf22a479fc71c5b1de35363a96b26e378403812450ce5b61c7535435482872639432bbafd3239c7ad9a9b600b8071f80ff268d96baadcdbfadaaf7987fb757fd56ab20917d3499147c4058eea27f4c24ecde02d70bc8fb4705957ffab6602d295e9253c17e3bd825539d84c02b070b02dd78cc39b4053ff4b79433a2b06b14f57af5b9a207596f69356750fdb41bd2b709255120c9bf1226f1e3b119af57f50186a1dc2a6cfe85064820b754d73a1d9571981c41374e0cd66509c26150fd61cd480f1c8701583d5e31affe98445744d0c93d54a52877b448cbb9d24fdd00e4eb2d6720bcc1a19204286f8c082c60805789a8dae370978667c282e72c8ac2571817cc63c42c208ddbb2b18f7b1d5775299d771830369c9d890aa80a75dacf71913cee9d6baa160703705608e1a7bb56c3bdb8d00b9fd37b98361fa42cf40603381a80bd0a053e764bb3370c47cb78cd537ca5645cbc6d8266aa9c976526d8644527b3779b6e632357d9f52b9079888356c13049a0cbeebeb41c85e132556169f406afe433a82092760a517fbbfc8fc41874a78b07d54d66e718ddebef737d8409cc40a7a9338ca191c8cfd9fc9261e81995da9fbd0d88fc5a59a17b749c79aebb853d1013c8c11e8b23ec18feef0fb221db9744fb4b595b81e8352672f3393617d35010d77ded24d495e98df3ccb23111ce44ab60bdf35a59ceccd416fe3d7403fcd252a279e39209e23827c7fde13d15d59af435a84a171798ba2fa4f89e9373a198e683f7221c060fb3da89d0aa463eefb5cfbc29880936f228bb3d407b18d3b74a9b6956d7767f8febc14324c9d495b86d3cb43e334cbaf5790cfbe537dd940b2c7a5d03be5d42e7a82ea211ba57cf955561713cc75d0a592a72006271ab6b5692bfd82b423e39dc0380443728ad28d8edfd4ee0660eeeefb57606fdbff0cf3472c1f31942228c3d3b30bdb03ee920778d44546239246f11aa343756aa6d6829caeaab106b19e1547661351e560d1e89ef0b46b184924102ad741af22c28069b467faec33a9337d7c8dc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>private</tag>
      </tags>
  </entry>
  <entry>
    <title>API安全技巧</title>
    <url>/posts/55de1c2a/</url>
    <content><![CDATA[<h1 id="API-安全的-12-个技巧"><a href="#API-安全的-12-个技巧" class="headerlink" title="API 安全的 12 个技巧"></a>API 安全的 12 个技巧</h1><span id="more"></span>

<p><img src="/../images/45d16bfb-c541-4c01-8574-63cc39a5c560_1280x1664.webp" alt="45d16bfb-c541-4c01-8574-63cc39a5c560_1280x1664.webp"></p>
<h1 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p>
<p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p>
<p>云冲印<br><img src="/../images/bg2014051202.png" alt="bg2014051202.png"></p>
<p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p>
<p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p>
<p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。<br>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。<br>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。<br>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。<br>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p>
<p>OAuth就是为了解决上面这些问题而诞生的。</p>
<p><img src="/../images/v2-fccac16d440911894f2ff356064563e9_1440w.webp" alt="v2-fccac16d440911894f2ff356064563e9_1440w.webp"><br>（A）用户打开客户端以后，客户端要求用户给予授权。<br>（B）用户同意给予客户端授权。<br>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。<br>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。<br>（E）客户端使用令牌，向资源服务器申请获取资源。<br>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JIT和AOT</title>
    <url>/posts/6c825f47/</url>
    <content><![CDATA[<h1 id="AOT，JIT是什么"><a href="#AOT，JIT是什么" class="headerlink" title="AOT，JIT是什么"></a>AOT，JIT是什么</h1><p>程序主要有两种运行方式：静态编译与动态解释。</p>
<p>静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；<br>而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。</p>
<span id="more"></span>

<blockquote>
<p>AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。</p>
</blockquote>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>这两种编译方式的主要区别在于是否在“运行时”进行编译。</p>
<h1 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h1><p>JIT优点：</p>
<ol>
<li>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）</li>
<li>可以根据当前程序的运行情况生成最优的机器指令序列</li>
<li>当程序需要支持动态链接时，只能使用JIT</li>
<li>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</li>
</ol>
<p>JIT缺点：</p>
<ol>
<li>编译需要占用运行时资源，会导致进程卡顿</li>
<li>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡</li>
<li>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</li>
</ol>
<p>AOT优点：</p>
<ol>
<li>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗</li>
<li>可以在程序运行初期就达到最高性能</li>
<li>可以显著的加快程序的启动</li>
</ol>
<p>AOT缺点： </p>
<ol>
<li>在程序运行前编译会使程序安装的时间增加</li>
<li>牺牲Java的一致性</li>
<li>将提前编译的内容保存会占用更多的外存</li>
</ol>
<h1 id="JIT深度解析"><a href="#JIT深度解析" class="headerlink" title="JIT深度解析"></a>JIT深度解析</h1><p><img src="/../images/213b5edeabce499182278d7730227019.png" alt="213b5edeabce499182278d7730227019.png"></p>
<p>对于一个长期运行的Java进程来说，每次执行都要经过 解释器 将程序翻译成机器指令去执行，那么这个效率就不是很好，这也是为什么Java被吐槽慢的缘故，<br>所以为了解决这个问题，才出现了 JIT。对于一些热点代码（经常被执行的，for循环）的一些代码，在运行时，JVM会将这些代码编译成机器可以执行的机器码，并缓存起来，这样下次执行这些代码的时候，就不需要再经过 解释器去编译了，机器可以直接运行这段程序，提高性能，这个就被称为 即时编译器，简称 JIT编译器。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/cristianoxm/article/details/126032096">JIT VS AOT</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>clean code</title>
    <url>/posts/73a9e291/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="命令查询分离"><a href="#命令查询分离" class="headerlink" title="命令查询分离"></a>命令查询分离</h2><p>函数要么做某事，要么回答某事，但不能两者兼而有之。</p>
<p><strong>错误示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String attribute, String value)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数设置某个指定属性，如果成功就返回 ue，如果不存在那个属性则返回 false。这样就导致了以下语句:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;unclebob&quot;</span>))...</span><br></pre></td></tr></table></figure>

<p><strong>正确示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (attributeExists(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">    setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;unclebob&quot;</span>);</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>最理想的参数数量是零(零参数函数)，其次是一《单参数函数)，再次是二 (双参数函数)，应尽量避免三 (三参数函数)。有足够特殊的理由才能用三个以上参数《多参数函数)-所以无论如何也不要这么做。</p>
<h2 id="使用异常替代返回错误码"><a href="#使用异常替代返回错误码" class="headerlink" title="使用异常替代返回错误码"></a>使用异常替代返回错误码</h2><p>从指令式函数返回错误码轻微违反了指令与询问分隔的规则。它鼓励了在 if语句判断中把指令当作表达式使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletePage(page) == E_OK)</span><br></pre></td></tr></table></figure>
<p>这不会引起动词&#x2F;形容词混淆，但却导致更深层次的嵌套结构。当返回错误码时，就是在要求调用者立刻处理错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletePage(page) == E_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.deleteReference(page.name) == E_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configKeys.deleteKey(page.name.makeKey()) == E_OK)&#123;</span><br><span class="line">            logger.log(<span class="string">&quot;page deleted&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.log(<span class="string">&quot;configKey not deleted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(<span class="string">&quot;deleteReference from registry failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    logger.log(<span class="string">&quot;delete failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> E_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name);</span><br><span class="line">    configKeys.deleteKey(page.name.makeKey());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.log(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不要使用标记位做为函数参数"><a href="#不要使用标记位做为函数参数" class="headerlink" title="不要使用标记位做为函数参数"></a>不要使用标记位做为函数参数</h2><p>标记位是告诉你的用户这个函数做了不只一件事情。 函数应该只做一件事情。 如果你的函数因为一个布尔值 出现不同的代码路径， 请拆分它们。</p>
<p><strong>错误示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createFile</span><span class="params">(String name,<span class="type">boolean</span> temp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./temp&quot;</span>+name);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">File</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createFile</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createTempFile</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./temp&quot;</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式编程优于指令式编程"><a href="#函数式编程优于指令式编程" class="headerlink" title="函数式编程优于指令式编程"></a>函数式编程优于指令式编程</h2><p><strong>错误示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; programmerOutput=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">programmerOutput.add(<span class="number">500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">150</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1000</span>);</span><br><span class="line"><span class="type">int</span> totalOutput=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;programmerOutput.size();i++)&#123;</span><br><span class="line">    totalOutput+=programmerOutput.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; programmerOutput = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">programmerOutput.add(<span class="number">500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">150</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1000</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">totalOutput</span> <span class="operator">=</span> programmerOutput.stream()</span><br><span class="line">        .filter(programmer -&gt; programmer &gt; <span class="number">500</span>)</span><br><span class="line">        .mapToInt(programmer -&gt; programmer)</span><br><span class="line">        .sum();</span><br></pre></td></tr></table></figure>

<h2 id="避免负面条件"><a href="#避免负面条件" class="headerlink" title="避免负面条件"></a>避免负面条件</h2><p><strong>错误示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">isDOMNodeNotPresent</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isDOMNodeNotPresent(node)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">isDOMNodePresent</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDOMNodePresent(node)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-getters-和-setters"><a href="#使用-getters-和-setters" class="headerlink" title="使用 getters 和 setters"></a>使用 getters 和 setters</h2><p><strong>错误示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BankAccount &#123;</span><br><span class="line">    public int balance=1000;</span><br><span class="line">&#125;</span><br><span class="line">BankAccount bankAccount=new BankAccount();</span><br><span class="line">bankAccount.balance-=100;</span><br></pre></td></tr></table></figure>

<p><strong>正确示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> blance=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBlance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> blance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBlance</span><span class="params">(<span class="type">int</span> blance)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(verifyIfAmountCanBeSetted(blance))&#123;</span><br><span class="line">                <span class="built_in">this</span>.blance = blance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">verifyIfAmountCanBeSetted</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BankAccount bankAccount=<span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line">    bankAccount.setBlance(<span class="number">2000</span>);</span><br><span class="line">    <span class="type">int</span> balance=bankAccount.getBlance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="不要返回Null值"><a href="#不要返回Null值" class="headerlink" title="不要返回Null值"></a>不要返回Null值</h2><p><strong>错误示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ItemRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> peristentStore.getItemRegistry();</span><br><span class="line">        <span class="keyword">if</span> (registry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Item</span> <span class="variable">existing</span> <span class="operator">=</span> registry.getItem(item.getID());</span><br><span class="line">            <span class="keyword">if</span> (existing.getBillingPeriod().hasRetailOwner()) &#123;</span><br><span class="line">                existing.register(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回 null值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 nul1 值，应用程序就会失控。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="keyword">if</span> (employees != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">        totalPay += e.getPay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">    totalPay += e.getPay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployees</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( .. there are no employees .. )</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="不要传递Null值"><a href="#不要传递Null值" class="headerlink" title="不要传递Null值"></a>不要传递Null值</h2><p>在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。除非 API要求你向它传递 null 值，否则就要尽可能避免传递 null 值。</p>
<p><strong>错误示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">xProjection</span><span class="params">(Point p1, Point p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p2.x – p1.x) * <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">xProjection</span><span class="params">(<span class="meta">@NotNull</span> Point p1, <span class="meta">@NotNull</span> Point p2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (p2.x – p1.x) * <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恰当的做法就是禁止传入 null 值。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://github.com/shizhongyu/clean-code-java">https://github.com/shizhongyu/clean-code-java</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>var 和 let</title>
    <url>/posts/bf2b1bc1/</url>
    <content><![CDATA[<h1 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a><strong>作用域：</strong></h1><ul>
<li><code>let</code> 具有块级作用域，只在声明的块或语句内部可见。</li>
<li><code>var</code> 具有函数级作用域，可在整个函数内部访问。</li>
</ul>
<p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的作用域区别：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>; <span class="comment">// 块级作用域内的变量</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">20</span>; <span class="comment">// 函数级作用域内的变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 输出 20</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 错误：x 未定义</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>x</code> 是使用 <code>let</code> 声明的变量，它只在 <code>if</code> 语句块内部可见。而 <code>y</code> 是使用 <code>var</code> 声明的变量，它在整个函数内部都可见。</p>
<span id="more"></span>

<h1 id="变量提升："><a href="#变量提升：" class="headerlink" title="变量提升："></a><strong>变量提升：</strong></h1><ul>
<li>使用 <code>let</code> 声明的变量不存在变量提升，必须在声明之后才能访问。</li>
<li>使用 <code>var</code> 声明的变量会被提升到其作用域的顶部，可以在声明之前访问。</li>
</ul>
<p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的变量提升区别：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 undefined</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 错误：y 未定义</span></span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，使用 <code>var</code> 声明的变量 <code>x</code> 在声明之前可以访问，但它的值为 <code>undefined</code>。而使用 <code>let</code> 声明的变量 <code>y</code> 在声明之前是不可访问的。</p>
<h1 id="重复声明："><a href="#重复声明：" class="headerlink" title="重复声明："></a><strong>重复声明：</strong></h1><ul>
<li>使用 <code>let</code> 声明的变量不允许在同一作用域内重复声明。</li>
<li>使用 <code>var</code> 声明的变量允许在同一作用域内重复声明，并且后面的声明会覆盖前面的声明。</li>
</ul>
<p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的重复声明区别：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">20</span>; <span class="comment">// 错误：无法重新声明块级作用域的</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>; <span class="comment">// 重复声明，覆盖前面的声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包与 var：</strong><br>使用 <code>var</code> 声明的变量在闭包中具有共享的作用域。这意味着闭包内部的函数可以访问和修改外部函数中声明的变量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>inner</code> 函数可以访问外部函数 <code>example</code> 中声明的变量 <code>x</code>。</p>
<p><strong>闭包与 let：</strong><br>使用 <code>let</code> 声明的变量在闭包中具有独立的作用域。每次迭代或调用闭包时，都会创建一个新的变量实例。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>setTimeout</code> 函数中的回调函数形成了闭包。使用 <code>let</code> 声明的变量 <code>i</code> 在每次迭代时都会创建一个新的实例，因此每个闭包都能够访问到正确的值。</p>
<p>相比之下，如果我们使用 <code>var</code> 声明变量 <code>i</code>，则所有的闭包都会共享同一个 <code>i</code>，导致输出结果为 <code>5</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5, 5, 5, 5, 5</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure>

<p>在这个示例中，由于 <code>var</code> 声明的 <code>i</code> 在全局作用域中共享，所有的闭包都使用了相同的 <code>i</code> 值。</p>
<p>通过使用 <code>let</code> 声明变量，我们确保了每个闭包都可以访问到正确的值，而不会受到循环的影响。</p>
]]></content>
  </entry>
  <entry>
    <title>V8技能树</title>
    <url>/posts/e4409905/</url>
    <content><![CDATA[<h1 id="什么是-V8"><a href="#什么是-V8" class="headerlink" title="什么是 V8?"></a>什么是 V8?</h1><p>V8 是 JavaScript 虚拟机的一种。将人类能够理解的编程语言 JavaScript，翻译成机器能够理解的机器语言。</p>
<span id="more"></span>

<p><img src="/../images/download.jpg" alt="download.jpg"></p>
<h1 id="V8编译流水线"><a href="#V8编译流水线" class="headerlink" title="V8编译流水线"></a>V8编译流水线</h1><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(1).jpeg" alt="下载 (1).jpeg"></p>
<ol>
<li>初始化基础环境；</li>
<li>解析源码生成 AST 和作用域；</li>
<li>依据 AST 和作用域生成字节码；</li>
<li>解释执行字节码；监听热点代码；</li>
<li>优化热点代码为二进制的机器代码；</li>
<li>反优化生成的二进制机器代码。</li>
</ol>
<p>这里你需要注意的是，JavaScript 是一门动态语言，在运行过程中，某些被优化的结构可能会被 V8 动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效了，那么编译器需要执行反优化操作。</p>
<p>编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内<br>联缓存等等。</p>
<p>要想充分了解 V8 是怎么工作的，除了要分析编译流水线，我们还需要了解另外两个非常重要的特性，那就是事件循环系统和垃圾回收机制。</p>
<h1 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h1><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(2).jpeg" alt="下载 (2).jpeg"></p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构</title>
    <url>/posts/926db354/</url>
    <content><![CDATA[<h1 id="五种前端架构"><a href="#五种前端架构" class="headerlink" title="五种前端架构"></a>五种前端架构</h1><span id="more"></span>

<p><img src="/../images/F_38UuNbEAACWtu.jpeg" alt="F_38UuNbEAACWtu.jpeg"></p>
]]></content>
  </entry>
  <entry>
    <title>网络</title>
    <url>/posts/50daec4/</url>
    <content><![CDATA[<h1 id="8-种常用网络协议"><a href="#8-种常用网络协议" class="headerlink" title="8 种常用网络协议"></a>8 种常用网络协议</h1><span id="more"></span>

<p><img src="/../images/20231021-bf786236-f777-481b-ba9e-65921c16752e.gif" alt="20231021-bf786236-f777-481b-ba9e-65921c16752e.gif"></p>
<h1 id="Cookies-与-Sessions"><a href="#Cookies-与-Sessions" class="headerlink" title="Cookies 与 Sessions"></a>Cookies 与 Sessions</h1><p><img src="/../images/c05744c903f54153a28805cd182107bb~tplv-obj_1280_1664.gif" alt="c05744c903f54153a28805cd182107bb~tplv-obj_1280_1664.gif"></p>
<h1 id="URL-URI-URN"><a href="#URL-URI-URN" class="headerlink" title="URL, URI, URN"></a>URL, URI, URN</h1><p><img src="/../images/0_cU9y8hm7YEjkVZBJ.webp" alt="0_cU9y8hm7YEjkVZBJ.webp"></p>
<h1 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h1><p><img src="/../images/1704001549342.gif" alt="1704001549342.gif"></p>
<h1 id="在浏览器中输入一个网址后到底发生了什么？"><a href="#在浏览器中输入一个网址后到底发生了什么？" class="headerlink" title="在浏览器中输入一个网址后到底发生了什么？"></a>在浏览器中输入一个网址后到底发生了什么？</h1><p><img src="/../images/8d954f9b42c64ea0ab9be4567e38f523~tplv-obj_550_715.gif" alt="8d954f9b42c64ea0ab9be4567e38f523~tplv-obj_550_715.gif"></p>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p><img src="/../images/1475ba84-8106-4d61-924e-6403cfdc1074_1280x1664.webp" alt="1475ba84-8106-4d61-924e-6403cfdc1074_1280x1664.webp"></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/663267550">用一张动图解释 8 种常用网络协议</a></li>
<li><a href="https://blog.bytebytego.com/p/ep80-explaining-8-popular-network">EP80: Explaining 8 Popular Network Protocols in 1 Diagram</a></li>
</ol>
]]></content>
  </entry>
</search>
